/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Event-Kit.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Event Kit
 #	author : miyako
 #	2019/10/14
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Event-Kit.h"

#pragma mark -

bool request_permission_granted_for_events = false;
bool request_permission_granted_for_reminders = false;

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- Event Kit
                
            case 1 :
                EK_STORE_Commit(params);
                break;
            case 2 :
                EK_SOURCE_Get_type(params);
                break;
            case 3 :
                EK_SOURCE_Get_title(params);
                break;
            case 4 :
                EK_SOURCE_LIST(params);
                break;
            case 5 :
                EK_SOURCE_Calendar_list(params);
                break;
            case 6 :
                EK_CALENDAR_Get_rgb_color(params);
                break;
            case 7 :
                EK_CALENDAR_Set_rgb_color(params);
                break;
            case 8 :
                EK_CALENDAR_Remove(params);
                break;
            case 9 :
                EK_CALENDAR_Save(params);
                break;
            case 10 :
                EK_CALENDAR_Get_default(params);
                break;
            case 11 :
                EK_CALENDAR_Get_type(params);
                break;
            case 12 :
                EK_CALENDAR_LIST(params);
                break;
            case 13 :
                EK_CALENDAR_Create(params);
                break;
            case 14 :
                EK_CALENDAR_Get_title(params);
                break;
            case 15 :
                EK_CALENDAR_Set_title(params);
                break;
            case 16 :
                EK_CALENDAR_Get_source(params);
                break;
            case 17 :
                EK_OBJECT_ROLLBACK(params);
                break;
            case 18 :
                EK_OBJECT_RESET(params);
                break;
            case 19 :
                EK_OBJECT_REFRESH(params);
                break;
            case 20 :
                EK_OBJECT_Has_changes(params);
                break;
            case 21 :
                EK_OBJECT_Is_new(params);
                break;
            case 22 :
                EK_ITEM_Get_attendees(params);
                break;
            case 23 :
                EK_ITEM_Get_calendar(params);
                break;
            case 24 :
                EK_ITEM_Get_title(params);
                break;
            case 25 :
                EK_ITEM_Set_title(params);
                break;
            case 26 :
                EK_ITEM_Get_location(params);
                break;
            case 27 :
                EK_ITEM_Set_location(params);
                break;
            case 28 :
                EK_ITEM_Get_url(params);
                break;
            case 29 :
                EK_ITEM_Set_url(params);
                break;
            case 30 :
                EK_ITEM_Get_notes(params);
                break;
            case 31 :
                EK_ITEM_Set_notes(params);
                break;
            case 32 :
                EK_ITEM_Get_alarms(params);
                break;
            case 33 :
                EK_ITEM_Set_alarms(params);
                break;
            case 34 :
                EK_ITEM_Get_rules(params);
                break;
            case 35 :
                EK_ITEM_Set_rules(params);
                break;
            case 36 :
                EK_ITEM_Get_timezone(params);
                break;
            case 37 :
                EK_ITEM_Set_timezone(params);
                break;
            case 38 :
                EK_ITEM_Set_calendar(params);
                break;
            case 39 :
                EK_ITEM_Get_attendee_names(params);
                break;
            case 40 :
                EK_ITEM_Get_modification_date(params);
                break;
            case 41 :
                EK_REMINDER_Create(params);
                break;
            case 42 :
                EK_REMINDER_Set_start_date(params);
                break;
            case 43 :
                EK_REMINDER_Get_start_date(params);
                break;
            case 44 :
                EK_REMINDER_Set_due_date(params);
                break;
            case 45 :
                EK_REMINDER_Get_due_date(params);
                break;
            case 46 :
                EK_REMINDER_Set_completed_date(params);
                break;
            case 47 :
                EK_REMINDER_Get_completed_date(params);
                break;
            case 48 :
                EK_REMINDER_Remove(params);
                break;
            case 49 :
                EK_REMINDER_Save(params);
                break;
            case 50 :
                EK_EVENT_Create(params);
                break;
            case 51 :
                EK_EVENT_Set_start_date(params);
                break;
            case 52 :
                EK_EVENT_Get_start_date(params);
                break;
            case 53 :
                EK_EVENT_Set_end_date(params);
                break;
            case 54 :
                EK_EVENT_Get_end_date(params);
                break;
            case 55 :
                EK_EVENT_Get_occurrence_date(params);
                break;
            case 56 :
                EK_EVENT_Get_status(params);
                break;
            case 57 :
                EK_EVENT_Get_all_day(params);
                break;
            case 58 :
                EK_EVENT_Set_all_day(params);
                break;
            case 59 :
                EK_EVENT_Get_organizer_name(params);
                break;
            case 60 :
                EK_EVENT_Save(params);
                break;
            case 61 :
                EK_EVENT_Remove(params);
                break;
            case 62 :
                EK_QUERY_EVENT(params);
                break;
            case 63 :
                EK_QUERY_COMPLETE_REMINDER(params);
                break;
            case 64 :
                EK_QUERY_INCOMPLETE_REMINDER(params);
                break;
            case 65 :
                EK_Request_permisson(params);
                break;
                
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark STORE

void EK_STORE_Commit(PA_PluginParameters params) {

    BOOL success = false;
    
    if(request_permission_granted_for_events) {
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        NSError *error;
        success = [sharedEventStore commit:&error];
        [sharedEventStore release];
    }
    
    PA_ReturnLong(params, success);
}

#pragma mark SOURCE

void EK_SOURCE_Get_type(PA_PluginParameters params) {

    BOOL success = false;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
        PA_SetLongParameter(params, 2, source ? source.sourceType : 0);
        success = source ? 1 : 0;
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_SOURCE_Get_title(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
        Param2.setUTF16String(source ? source.title : @"");
        success = source ? 1 : 0;
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
    Param2.toParamAtIndex(pParams, 2);
}

void EK_SOURCE_LIST(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    ARRAY_TEXT Param1;
    
    if(request_permission_granted_for_events) {
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        NSArray *sources = [sharedEventStore sources];
        for(unsigned int i = 0; i < [sources count]; ++i)
        {
            EKSource *source = [sources objectAtIndex:i];
            Param1.appendUTF16String(source.sourceIdentifier);
        }
        [sharedEventStore release];
    }
    Param1.toParamAtIndex(pParams, 1);
}

void EK_SOURCE_Calendar_list(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    ARRAY_TEXT Param2;
    C_LONGINT Param3;
    C_LONGINT returnValue;
    
    Param3.fromParamAtIndex(pParams, 3);
    
    switch (Param3.getIntValue())
    {
        case 1://reminders
        if(request_permission_granted_for_reminders) {
            PA_Unistring *u = PA_GetStringParameter(params, 1);
            NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
            
            success = source ? 1 : 0;
            
            NSArray *calendars = [[source calendarsForEntityType:EKEntityTypeReminder]allObjects];
            
            for(unsigned int i = 0; i < [calendars count]; ++i)
            {
                EKCalendar *calendar = [calendars objectAtIndex:i];
                Param2.appendUTF16String(calendar.calendarIdentifier);
            }
            
            [sharedEventStore release];
            [identifier release];
        }
        break;
        default:
        if(request_permission_granted_for_events) {
            PA_Unistring *u = PA_GetStringParameter(params, 1);
            NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
            
            success = source ? 1 : 0;
            
            NSArray *calendars = [[source calendarsForEntityType:EKEntityTypeEvent]allObjects];
            
            for(unsigned int i = 0; i < [calendars count]; ++i)
            {
                EKCalendar *calendar = [calendars objectAtIndex:i];
                Param2.appendUTF16String(calendar.calendarIdentifier);
            }

            [sharedEventStore release];
            [identifier release];
        }
        break;
    }
    
    PA_ReturnLong(params, success);
}

#pragma mark CALENDAR

BOOL saveCalendar(EKEventStore *sharedEventStore, EKCalendar *calendar) {
    
    NSError *error;
    BOOL success = [sharedEventStore saveCalendar:calendar commit:NO error:&error];
    if(!success){
        NSLog(@"calendar save failed: %@", [error description]);
        return FALSE;
    }else{
        return TRUE;
    }
}

BOOL removeCalendar(EKEventStore *sharedEventStore, EKCalendar *calendar) {
    
    NSError *error;
    BOOL success = [sharedEventStore removeCalendar:calendar commit:NO error:&error];
    if(!success){
        NSLog(@"calendar remove failed: %@", [error description]);
        return FALSE;
    }else{
        return TRUE;
    }
}

void EK_CALENDAR_Get_rgb_color(PA_PluginParameters params) {

    BOOL success = false;
    
    C_TEXT Param1;
    C_REAL Param2;
    C_REAL Param3;
    C_REAL Param4;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            NSColor *color = calendar.color;
            if(color)
            {
                CGFloat red, green, blue, alpha;
                [color getRed:&red green:&green blue:&blue alpha:&alpha];
                Param2.setDoubleValue(red);
                Param3.setDoubleValue(green);
                Param4.setDoubleValue(blue);
                success = true;
            }
            
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    Param4.toParamAtIndex(pParams, 4);
    
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_Set_rgb_color(PA_PluginParameters params) {

    BOOL success = false;
    
    C_TEXT Param1;
    C_REAL Param2;
    C_REAL Param3;
    C_REAL Param4;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;

    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            NSColor *color = [NSColor colorWithDeviceRed:Param2.getDoubleValue() green:Param3.getDoubleValue() blue:Param4.getDoubleValue() alpha:1];
            calendar.color = color;
            
            success = saveCalendar(sharedEventStore, calendar);
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_Remove(PA_PluginParameters params) {

     BOOL success = false;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            success = removeCalendar(sharedEventStore, calendar);
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_Save(PA_PluginParameters params) {

    BOOL success = false;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            success = saveCalendar(sharedEventStore, calendar);
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_Get_default(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param1;
    C_TEXT Param2;
    
    Param1.fromParamAtIndex(pParams, 1);
    
    switch (Param1.getIntValue())
    {
        case 1://reminders
        if(request_permission_granted_for_reminders) {
            PA_Unistring *u = PA_GetStringParameter(params, 1);
            NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            
            Param2.setUTF16String(sharedEventStore.defaultCalendarForNewReminders.calendarIdentifier);
            success = 0 != [sharedEventStore.defaultCalendarForNewReminders.calendarIdentifier length];
            
            [sharedEventStore release];
            [identifier release];
        }
        break;
        
        default:
        if(request_permission_granted_for_events) {
            PA_Unistring *u = PA_GetStringParameter(params, 1);
            NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            
            Param2.setUTF16String(sharedEventStore.defaultCalendarForNewEvents.calendarIdentifier);
            success = 0 != [sharedEventStore.defaultCalendarForNewEvents.calendarIdentifier length];
            
            [sharedEventStore release];
            [identifier release];
        }
        break;
    }

    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_Get_type(PA_PluginParameters params) {

    BOOL success = false;
    
    C_LONGINT Param2;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            Param2.setIntValue(calendar.type);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_LIST(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param1;
    C_LONGINT Param2;
    
    Param2.fromParamAtIndex(pParams, 2);
    
    switch (Param2.getIntValue())
    {
        case 1://reminders
        if(request_permission_granted_for_reminders) {

            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            
            NSArray *calendars = [sharedEventStore calendarsForEntityType:EKEntityTypeReminder];
            
            for(unsigned int i = 0; i < [calendars count]; ++i)
            {
                EKCalendar *calendar = [calendars objectAtIndex:i];
                Param1.appendUTF16String(calendar.calendarIdentifier);
            }
            Param1.toParamAtIndex(pParams, 1);
            
            [sharedEventStore release];
        }
        break;
        
        default:
        if(request_permission_granted_for_events) {

            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            
            NSArray *calendars = [sharedEventStore calendarsForEntityType:EKEntityTypeEvent];
            
            for(unsigned int i = 0; i < [calendars count]; ++i)
            {
                EKCalendar *calendar = [calendars objectAtIndex:i];
                Param1.appendUTF16String(calendar.calendarIdentifier);
            }
            Param1.toParamAtIndex(pParams, 1);
            
            [sharedEventStore release];
        }
        break;
    }
    
}

void EK_CALENDAR_Create(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    
    C_LONGINT Param2;
    Param2.fromParamAtIndex(pParams, 2);
    
    C_TEXT returnValue;
    
    switch (Param2.getIntValue())
    {
        case 1://reminders
        if(request_permission_granted_for_reminders) {
            PA_Unistring *u = PA_GetStringParameter(params, 1);
            NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            
            EKCalendar *calendar = [EKCalendar calendarForEntityType:EKEntityTypeReminder eventStore:sharedEventStore];
            
            if(calendar)
            {
                if(saveCalendar(sharedEventStore, calendar))
                {
                    returnValue.setUTF16String(calendar.calendarIdentifier);
                }
            }
            
            [sharedEventStore release];
            [identifier release];
        }
        break;
        
        default:
        if(request_permission_granted_for_events) {
            PA_Unistring *u = PA_GetStringParameter(params, 1);
            NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
            EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
            
            EKCalendar *calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:sharedEventStore];
            
            if(calendar)
            {
                if(saveCalendar(sharedEventStore, calendar))
                {
                    returnValue.setUTF16String(calendar.calendarIdentifier);
                }
            }

            [sharedEventStore release];
            [identifier release];
        }
        break;
    }
    
    returnValue.setReturn(pResult);
}

void EK_CALENDAR_Get_title(PA_PluginParameters params) {

    BOOL success = false;
    
    C_TEXT Param2;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            Param2.setUTF16String(calendar.title);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_Set_title(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    Param2.fromParamAtIndex(pParams, 2);
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            NSString *title = Param2.copyUTF16String();
            calendar.title = title;
            [title release];
            
            success = saveCalendar(sharedEventStore, calendar);
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_CALENDAR_Get_source(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(calendar)
        {
            Param2.setUTF16String([calendar.source sourceIdentifier]);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

id getItem(EKEventStore *sharedEventStore, NSString *identifier) {
    
    EKCalendarItem *item = nil;
    NSArray *items = [sharedEventStore calendarItemsWithExternalIdentifier:identifier];
    if([items count]) item = [items objectAtIndex:0];
    
    return item;
}

#pragma mark OBJECT

void EK_OBJECT_ROLLBACK(PA_PluginParameters params) {

    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
        
        if(source){
            [source rollback];
            NSLog(@"rolled back source '%@'", identifier);
        }else{
            EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
            if(calendar){
                [calendar rollback];
                NSLog(@"rolled back calendar '%@'", identifier);
            }else{
                EKCalendarItem *item = getItem(sharedEventStore, identifier);
                if(item){
                    [item rollback];
                    NSLog(@"rolled back item '%@'", identifier);
                }else{
                    NSLog(@"'%@' is not a valid object to roll back", identifier);
                }
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
}

void EK_OBJECT_RESET(PA_PluginParameters params) {

    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
        
        if(source){
            [source reset];
            NSLog(@"resetted source '%@'", identifier);
        }else{
            EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
            if(calendar){
                [calendar reset];
                NSLog(@"resetted calendar '%@'", identifier);
            }else{
                EKCalendarItem *item = getItem(sharedEventStore, identifier);
                if(item){
                    [item reset];
                    NSLog(@"resetted item '%@'", identifier);
                }else{
                    [sharedEventStore reset];
                    NSLog(@"resetted store");
                }
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
}

void EK_OBJECT_REFRESH(PA_PluginParameters params) {

    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
        
        if(source){
            [source refresh];
            NSLog(@"refreshed source '%@'", identifier);
        }else{
            EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
            if(calendar){
                [calendar refresh];
                NSLog(@"refreshed calendar '%@'", identifier);
            }else{
                EKCalendarItem *item = getItem(sharedEventStore, identifier);
                if(item){
                    [item refresh];
                    NSLog(@"refreshed item '%@'", identifier);
                }else{
                    [sharedEventStore refreshSourcesIfNecessary];
                    NSLog(@"refreshed store");
                }
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
}

void EK_OBJECT_Has_changes(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
        
        if(source){
            Param2.setIntValue([source hasChanges]);
        }else{
            EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
            if(calendar){
                Param2.setIntValue([calendar hasChanges]);
                success = true;
            }else{
                EKCalendarItem *item = getItem(sharedEventStore, identifier);
                if(item){
                    Param2.setIntValue([item hasChanges]);
                    success = true;
                }else{
                    NSLog(@"'%@' is not a valid object to report changes", identifier);
                }
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_OBJECT_Is_new(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
        
        if(source){
            Param2.setIntValue([source isNew]);
        }else{
            EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
            if(calendar){
                Param2.setIntValue([calendar isNew]);
                success = true;
            }else{
                EKCalendarItem *item = getItem(sharedEventStore, identifier);
                if(item){
                    Param2.setIntValue([item isNew]);
                    success = true;
                }else{
                    NSLog(@"'%@' is not a valid object to report if new", identifier);
                }
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

#pragma mark SAVE / REMOVE

BOOL saveEvent(EKEventStore *sharedEventStore, EKEvent *event, BOOL commit = NO) {
    
    NSError *error;
    BOOL success = [sharedEventStore saveEvent:event span:EKSpanThisEvent commit:commit error:&error];
    if(!success){
        NSLog(@"event save failed: %@", [error description]);
        return FALSE;
    }else{
        return TRUE;
    }
}

BOOL removeEvent(EKEventStore *sharedEventStore, EKEvent *event, BOOL commit = NO) {
    
    NSError *error;
    BOOL success = [sharedEventStore removeEvent:event span:EKSpanThisEvent commit:commit error:&error];
    
    if(!success){
        NSLog(@"event remove failed: %@", [error description]);
        return FALSE;
    }else{
        return TRUE;
    }
}

BOOL saveReminder(EKEventStore *sharedEventStore, EKReminder *reminder, BOOL commit = NO) {
    
    NSError *error;
    BOOL success = [sharedEventStore saveReminder:reminder commit:commit error:&error];
    
    if(!success){
        NSLog(@"reminder save failed: %@", [error description]);
        return FALSE;
    }else{
        return TRUE;
    }
}

BOOL removeReminder(EKEventStore *sharedEventStore, EKReminder *reminder, BOOL commit = NO) {
    
    NSError *error;
    BOOL success = [sharedEventStore removeReminder:reminder commit:commit error:&error];
    
    if(!success){
        NSLog(@"reminder remove failed: %@", [error description]);
        return FALSE;
    }else{
        return TRUE;
    }
}

BOOL saveItem(EKEventStore *sharedEventStore, EKCalendarItem *item, BOOL commit = NO) {
    
    if(item)
    {
        if([item isKindOfClass:[EKEvent class]])
        if(saveEvent(sharedEventStore, (EKEvent *)item, commit))
        return TRUE;
        
        if([item isKindOfClass:[EKReminder class]])
        if(saveReminder(sharedEventStore, (EKReminder *)item, commit))
        return TRUE;
    }
    return FALSE;
}

void setArray(NSArray *array, ARRAY_TEXT &ParamArray) {
    
    ParamArray.setSize(0);
    
    if(array){
        for(unsigned int i = 0; i < [array count]; ++i){
            
            ParamArray.appendUTF16String([array objectAtIndex:i]);
            
        }
    }
}

NSArray * copyArray(ARRAY_TEXT &ParamArray) {
    
    NSUInteger capacity = ParamArray.getSize();
    NSMutableArray *array = [[NSMutableArray alloc]initWithCapacity:capacity];
    
    if(array){
        for(unsigned int i = 0; i < ParamArray.getSize(); ++i){
            
            NSString *item = ParamArray.copyUTF16StringAtIndex(i);
            [array addObject:item];
            [item release];
            
        }
    }
    return array;
}

BOOL setDate(NSDate *date, C_DATE &ParamDate, C_TIME &ParamTime) {
    
    if(date){
        
        NSString *description = [date description];
        
        if([description length] == 25)
        {
            uint16_t year = [[description substringWithRange:NSMakeRange(0,4)]integerValue];
            uint16_t month = [[description substringWithRange:NSMakeRange(5,2)]integerValue];
            uint16_t day = [[description substringWithRange:NSMakeRange(8,2)]integerValue];
            
            unsigned char hour = [[description substringWithRange:NSMakeRange(11,2)]integerValue];
            unsigned char minute = [[description substringWithRange:NSMakeRange(14,2)]integerValue];
            unsigned char second = [[description substringWithRange:NSMakeRange(17,2)]integerValue];
            
            ParamDate.setYearMonthDay(year, month, day);
            ParamTime.setHourMinuteSecond(hour, minute, second);
            
            return TRUE;
        }
    }
    return FALSE;
}

NSDate *copyDate(C_DATE &ParamDate, C_TIME &ParamTime) {
    
    uint16_t year;
    uint16_t month;
    uint16_t day;
    
    unsigned char hour;
    unsigned char minute;
    unsigned char second;
    
    ParamDate.getYearMonthDay(&year, &month, &day);
    ParamTime.getHourMinuteSecond(&hour, &minute, &second);
    
    CFGregorianDate gregDate;
    gregDate.year = year;
    gregDate.month = month;
    gregDate.day = day;
    gregDate.hour = hour;
    gregDate.minute = minute;
    gregDate.second = second;
    
    return (NSDate *)CFDateCreate(kCFAllocatorDefault, CFGregorianDateGetAbsoluteTime(gregDate, (CFTimeZoneRef)[NSTimeZone localTimeZone]));
}

NSArray *getCalendars(EKEventStore *sharedEventStore, ARRAY_TEXT &ParamArray) {
    
    NSUInteger capacity = ParamArray.getSize();
    NSMutableArray *array = [[NSMutableArray alloc]initWithCapacity:capacity];
    
    if(array){
        for(unsigned int i = 0; i < ParamArray.getSize(); ++i){
            
            NSString *item = ParamArray.copyUTF16StringAtIndex(i);
            EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:item];
            if(calendar)
            {
                [array addObject:calendar];
            }
            [item release];
        }
    }
    return array;
}

#pragma mark ITEM

void EK_ITEM_Get_attendees(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            NSMutableArray *attendeeJsons = [[NSMutableArray alloc]init];
            
            NSArray *attendees = item.attendees;
            for (EKParticipant *attendee in attendees){
                
                NSString *name = attendee.name;
                NSNumber *participantRole = [NSNumber numberWithInt:attendee.participantRole];
                NSNumber *participantStatus = [NSNumber numberWithInt:attendee.participantStatus];
                
                id url;
                if(attendee.URL){
                    url = [attendee.URL absoluteString];
                }else{
                    url = [NSNull null];
                }
                
                NSDictionary *attendeeJson = [NSDictionary dictionaryWithObjects:
                                              
                                              [NSArray arrayWithObjects:
                                               name,
                                               participantRole,
                                               participantStatus,
                                               url,
                                               nil]
                                                                         forKeys:
                                              
                                              [NSArray arrayWithObjects:
                                               @"name",
                                               @"participantRole",
                                               @"participantStatus",
                                               @"url",
                                               nil]];
                NSError *error;
                NSData *jsonData = [NSJSONSerialization dataWithJSONObject:attendeeJson options:0 error:&error];
                
                if(jsonData){
                    const void *bytes = [jsonData bytes];
                    if(bytes){
                        [attendeeJsons addObject:[NSString stringWithUTF8String:(const char *)bytes]];
                    }
                }
            }
            
            setArray(attendeeJsons, Param2);
            [attendeeJsons release];
            success = true;

        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_calendar(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            Param2.setUTF16String(item.calendar.calendarIdentifier);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_calendar(PA_PluginParameters params) {
    
    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        Param2.fromParamAtIndex(pParams, 2);
        NSString *calendar = Param2.copyUTF16String();
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            EKCalendar *itemCalendar = [sharedEventStore calendarWithIdentifier:calendar];
            
            if(!itemCalendar){
                NSLog(@"'%@' is not a calendar", calendar);
            }else{
                item.calendar = itemCalendar;
                success = saveItem(sharedEventStore, item, YES);
            }
        }
        
        [calendar release];
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_title(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            Param2.setUTF16String(item.title);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_title(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            Param2.fromParamAtIndex(pParams, 2);
            NSString *title = Param2.copyUTF16String();
            item.title = title;
            [title release];
            success = saveItem(sharedEventStore, item, YES);
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_location(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            Param2.setUTF16String(item.location);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_location(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            Param2.fromParamAtIndex(pParams, 2);
            NSString *location = Param2.copyUTF16String();
            item.location = location;
            [location release];
            
            success = saveItem(sharedEventStore, item, YES);
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_url(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            Param2.setUTF16String([item.URL absoluteString]);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_url(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];

        Param2.fromParamAtIndex(pParams, 2);
        NSString *url = Param2.copyUTF16String();
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            NSURL *URL = [NSURL URLWithString:url];
            if(URL){
                item.URL = URL;
                success = saveItem(sharedEventStore, item, YES);
            }
        }
        
        [url release];
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_notes(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            Param2.setUTF16String(item.notes);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_notes(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        Param2.fromParamAtIndex(pParams, 2);
        NSString *notes = Param2.copyUTF16String();
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            item.notes = notes;
            success = saveItem(sharedEventStore, item, YES);
        }
        
        [notes release];
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_alarms(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            NSMutableArray *itemAlarms = [[NSMutableArray alloc]init];
            NSArray *alarms = item.attendees;
            for (EKAlarm *alarm in alarms){
                
                NSNumber *type = [NSNumber numberWithInt:alarm.type];
                
                id soundName;
                if(alarm.soundName){
                    soundName = alarm.soundName;
                }else{
                    soundName = [NSNull null];
                }
                
                id emailAddress;
                if(alarm.emailAddress){
                    emailAddress = alarm.emailAddress;
                }else{
                    emailAddress = [NSNull null];
                }
                
                id url;
                if(alarm.url){
                    url = [alarm.url absoluteString];
                }else{
                    url = [NSNull null];
                }
                
                id relativeOffset;
                if(alarm.relativeOffset){
                    relativeOffset = [NSNumber numberWithInt:alarm.relativeOffset];
                }else{
                    relativeOffset = [NSNull null];
                }
                
                id absoluteDate;
                if(alarm.absoluteDate){
                    absoluteDate = [alarm.absoluteDate description];
                }else{
                    absoluteDate = [NSNull null];
                }
                
                id proximity;
                if(alarm.proximity){
                    proximity = [NSNumber numberWithInt:alarm.proximity];
                }else{
                    proximity = [NSNull null];
                }
                
                id structuredLocation;
                if(alarm.structuredLocation){
                    structuredLocation = [NSDictionary dictionaryWithObjects:
                                          
                                          [NSArray arrayWithObjects:
                                           alarm.structuredLocation.title,
                                           [NSNumber numberWithDouble:alarm.structuredLocation.radius],
                                           [NSNumber numberWithDouble:alarm.structuredLocation.geoLocation.coordinate.latitude],
                                           [NSNumber numberWithDouble:alarm.structuredLocation.geoLocation.coordinate.longitude],
                                           [NSNumber numberWithDouble:alarm.structuredLocation.geoLocation.altitude],
                                           nil]
                                                                     forKeys:
                                          
                                          [NSArray arrayWithObjects:
                                           @"title",
                                           @"radius",
                                           @"latitude",
                                           @"longitude",
                                           @"altitude",
                                           nil]];
                    
                }else{
                    structuredLocation = [NSNull null];
                }
                
                NSDictionary *alarmJson = [NSDictionary dictionaryWithObjects:
                                           
                                           [NSArray arrayWithObjects:
                                            type,
                                            soundName,
                                            emailAddress,
                                            url,
                                            relativeOffset,
                                            absoluteDate,
                                            proximity,
                                            structuredLocation,
                                            nil]
                                           
                                                                      forKeys:
                                           
                                           [NSArray arrayWithObjects:
                                            @"type",
                                            @"soundName",
                                            @"emailAddress",
                                            @"url",
                                            @"relativeOffset",
                                            @"absoluteDate",
                                            @"proximity",
                                            @"structuredLocation",
                                            nil]];
                NSError *error;
                NSData *jsonData = [NSJSONSerialization dataWithJSONObject:alarmJson options:0 error:&error];
                
                if(jsonData){
                    const void *bytes = [jsonData bytes];
                    if(bytes){
                        [itemAlarms addObject:[NSString stringWithUTF8String:(const char *)bytes]];
                    }
                }
            }
            
            setArray(itemAlarms, Param2);
            [itemAlarms release];
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_alarms(PA_PluginParameters params) {

    if(request_permission_granted_for_events) {
        
    }
}

void EK_ITEM_Get_rules(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            NSMutableArray *itemRules = [[NSMutableArray alloc]init];
            NSArray *rules = item.recurrenceRules;
            for (EKRecurrenceRule *rule in rules){
                
                NSNumber *frequency = [NSNumber numberWithInt:rule.frequency];
                NSNumber *interval = [NSNumber numberWithInt:rule.interval];
                NSNumber *firstDayOfTheWeek = [NSNumber numberWithInt:rule.firstDayOfTheWeek];
                
                id recurrenceEnd;
                if(rule.recurrenceEnd){
                    recurrenceEnd = [NSDictionary dictionaryWithObjects:
                                     
                                     [NSArray arrayWithObjects:
                                      [rule.recurrenceEnd.endDate description],
                                      [NSNumber numberWithInt:rule.recurrenceEnd.occurrenceCount],
                                      nil]
                                                                forKeys:
                                     
                                     [NSArray arrayWithObjects:
                                      @"endDate",
                                      @"occurrenceCount",
                                      nil]];
                    
                }else{
                    recurrenceEnd = [NSNull null];
                }
                
                id daysOfTheWeek;
                if(rule.daysOfTheWeek){
                    
                    daysOfTheWeek = [NSMutableArray array];
                    
                    for (EKRecurrenceDayOfWeek *dow in rule.daysOfTheWeek){
                        
                        NSDictionary *recurrence = [NSDictionary dictionaryWithObjects:
                                                    
                                                    [NSArray arrayWithObjects:
                                                     [NSNumber numberWithInt:dow.dayOfTheWeek],
                                                     [NSNumber numberWithInt:dow.weekNumber],
                                                     nil]
                                                                               forKeys:
                                                    
                                                    [NSArray arrayWithObjects:
                                                     @"dayOfTheWeek",
                                                     @"weekNumber",
                                                     nil]];
                        
                        [daysOfTheWeek addObject:recurrence];
                        
                    }
                    
                }else{
                    daysOfTheWeek = [NSNull null];
                }
                
                id daysOfTheMonth;
                if(rule.daysOfTheMonth){
                    daysOfTheMonth = rule.daysOfTheMonth;
                }else{
                    daysOfTheMonth = [NSNull null];
                }
                
                id daysOfTheYear;
                if(rule.daysOfTheYear){
                    daysOfTheYear = rule.daysOfTheYear;
                }else{
                    daysOfTheYear = [NSNull null];
                }
                
                id weeksOfTheYear;
                if(rule.weeksOfTheYear){
                    weeksOfTheYear = rule.weeksOfTheYear;
                }else{
                    weeksOfTheYear = [NSNull null];
                }
                
                id monthsOfTheYear;
                if(rule.monthsOfTheYear){
                    monthsOfTheYear = rule.monthsOfTheYear;
                }else{
                    monthsOfTheYear = [NSNull null];
                }
                
                id setPositions;
                if(rule.setPositions){
                    setPositions = rule.setPositions;
                }else{
                    setPositions = [NSNull null];
                }
                
                NSDictionary *alarmJson = [NSDictionary dictionaryWithObjects:
                                           
                                           [NSArray arrayWithObjects:
                                            frequency,
                                            interval,
                                            firstDayOfTheWeek,
                                            daysOfTheWeek,
                                            daysOfTheMonth,
                                            daysOfTheYear,
                                            weeksOfTheYear,
                                            monthsOfTheYear,
                                            setPositions,
                                            nil]
                                           
                                                                      forKeys:
                                           
                                           [NSArray arrayWithObjects:
                                            @"frequency",
                                            @"interval",
                                            @"firstDayOfTheWeek",
                                            @"daysOfTheWeek",
                                            @"daysOfTheMonth",
                                            @"daysOfTheYear",
                                            @"weeksOfTheYear",
                                            @"monthsOfTheYear",
                                            @"setPositions",
                                            nil]];
                NSError *error;
                NSData *jsonData = [NSJSONSerialization dataWithJSONObject:alarmJson options:0 error:&error];
                
                if(jsonData){
                    const void *bytes = [jsonData bytes];
                    if(bytes){
                        [itemRules addObject:[NSString stringWithUTF8String:(const char*)bytes]];
                    }
                }
            }
            
            setArray(itemRules, Param2);
            [itemRules release];
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_rules(PA_PluginParameters params) {

    if(request_permission_granted_for_events) {
        
    }
}

void EK_ITEM_Get_timezone(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            NSTimeZone *tz = item.timeZone;
            if(tz){
                Param2.setUTF16String([tz abbreviation]);
                success = true;
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Set_timezone(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        Param2.fromParamAtIndex(pParams, 2);
        NSString *zone = Param2.copyUTF16String();
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            NSTimeZone *tz = [NSTimeZone timeZoneWithAbbreviation:zone];
            if(tz){
                item.timeZone = tz;
                success = saveItem(sharedEventStore, item, YES);
            }
        }
        
        [zone release];
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_attendee_names(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    ARRAY_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        Param2.setSize(1);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            NSArray *attendees = item.attendees;
            for (EKParticipant *attendee in attendees)
            {
                Param2.appendUTF16String(attendee.name);
            }
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_ITEM_Get_modification_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' is not a calendar item", identifier);
        }else{
            setDate(item.lastModifiedDate, Param2, Param3);
            success = true;
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    PA_ReturnLong(params, success);
}

#pragma mark REMINDER

void EK_REMINDER_Create(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    
    C_TEXT returnValue;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(!calendar){
            calendar = sharedEventStore.defaultCalendarForNewReminders;
        }
        
        if(!calendar){
            NSLog(@"'%@' is not a calendar", identifier);
        }else{
            EKReminder *reminder = [EKReminder reminderWithEventStore:sharedEventStore];
            reminder.calendar = calendar;
            
            if(saveReminder(sharedEventStore, reminder, YES))
            {
                //            returnValue.setUTF16String([reminder calendarItemIdentifier]);
                returnValue.setUTF16String([reminder calendarItemExternalIdentifier]);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    returnValue.setReturn(pResult);
}

void EK_REMINDER_Set_start_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        Param2.fromParamAtIndex(pParams, 2);
        Param3.fromParamAtIndex(pParams, 3);
        
        NSDate *date = copyDate(Param2, Param3);
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKReminder class]]){
                
                EKReminder *reminder = (EKReminder *)item;
                NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
                NSUInteger dateComponentUnits = NSYearCalendarUnit|
                NSMonthCalendarUnit|
                NSDayCalendarUnit|
                NSHourCalendarUnit|
                NSMinuteCalendarUnit|
                NSSecondCalendarUnit|
                NSCalendarCalendarUnit|
                NSTimeZoneCalendarUnit;
                reminder.startDateComponents = [gregorianCalendar components:dateComponentUnits fromDate:date];
               
                success = saveItem(sharedEventStore, item, YES);
                [gregorianCalendar release];
                
            }else{
                NSLog(@"'%@' is not a reminder", identifier);
            }
        }
        
        [date release];
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_REMINDER_Get_start_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKReminder class]]){
                
                EKReminder *reminder = (EKReminder *)item;
                NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
                
                /*
                 NSUInteger dateComponentUnits = NSYearCalendarUnit|
                 NSMonthCalendarUnit|
                 NSDayCalendarUnit|
                 NSHourCalendarUnit|
                 NSMinuteCalendarUnit|
                 NSSecondCalendarUnit|
                 NSCalendarCalendarUnit|
                 NSTimeZoneCalendarUnit;
                 */

                NSDate *date = [gregorianCalendar dateFromComponents:reminder.startDateComponents];
                setDate(date, Param2, Param3);
                
                success = true;
                
            }else{
                NSLog(@"'%@' is not a reminder", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    PA_ReturnLong(params, success);
}

void EK_REMINDER_Set_due_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKReminder class]]){
                
                EKReminder *reminder = (EKReminder *)item;
                NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
                NSUInteger dateComponentUnits = NSYearCalendarUnit|
                NSMonthCalendarUnit|
                NSDayCalendarUnit|
                NSHourCalendarUnit|
                NSMinuteCalendarUnit|
                NSSecondCalendarUnit|
                NSCalendarCalendarUnit|
                NSTimeZoneCalendarUnit;
                
                Param2.fromParamAtIndex(pParams, 2);
                Param3.fromParamAtIndex(pParams, 3);
                NSDate *date = copyDate(Param2, Param3);
                
                reminder.dueDateComponents = [gregorianCalendar components:dateComponentUnits fromDate:date];
                success = saveItem(sharedEventStore, item, YES);
                [date release];
                
                [gregorianCalendar release];
                
            }else{
                NSLog(@"'%@' is not a reminder", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_REMINDER_Get_due_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKReminder class]]){
                
                EKReminder *reminder = (EKReminder *)item;
                NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
                /*
                 NSUInteger dateComponentUnits = NSYearCalendarUnit|
                 NSMonthCalendarUnit|
                 NSDayCalendarUnit|
                 NSHourCalendarUnit|
                 NSMinuteCalendarUnit|
                 NSSecondCalendarUnit|
                 NSCalendarCalendarUnit|
                 NSTimeZoneCalendarUnit;
                 */

                NSDate *date = [gregorianCalendar dateFromComponents:reminder.dueDateComponents];
                setDate(date, Param2, Param3);
                success = true;
                
            }else{
                NSLog(@"'%@' is not a reminder", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    PA_ReturnLong(params, success);
}

void EK_REMINDER_Set_completed_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKReminder class]]){
                
                EKReminder *reminder = (EKReminder *)item;
                
                Param2.fromParamAtIndex(pParams, 2);
                Param3.fromParamAtIndex(pParams, 3);
                NSDate *date = copyDate(Param2, Param3);
                reminder.completionDate = date;
                success = saveItem(sharedEventStore, item, YES);
                [date release];
                
            }else{
                NSLog(@"'%@' is not a reminder", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_REMINDER_Get_completed_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKReminder class]]){
                
                EKReminder *reminder = (EKReminder *)item;
                setDate(reminder.completionDate, Param2, Param3);
                success = true;
                
            }else{
                NSLog(@"'%@' is not a reminder", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    PA_ReturnLong(params, success);
}

void EK_REMINDER_Remove(PA_PluginParameters params) {

    BOOL success = false;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKReminder class]]){
                
                EKReminder *reminder = item;
                
                success = removeReminder(sharedEventStore, reminder, YES);
                
            }else{
                NSLog(@"'%@' is not a reminder", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_REMINDER_Save(PA_PluginParameters params) {

    BOOL success = false;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            
            success = saveItem(sharedEventStore, item, YES);
            
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_EVENT_Create(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    
    C_TEXT returnValue;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
        
        if(!calendar){
            calendar = sharedEventStore.defaultCalendarForNewEvents;
        }
        
        if(!calendar){
            NSLog(@"'%@' is not a calendar", identifier);
        }else{
            EKEvent *event = [EKEvent eventWithEventStore:sharedEventStore];
            event.calendar = calendar;
            
            //mandatory properties to perform save
            event.startDate = [NSDate date];
            event.endDate = [NSDate date];
            
            if(saveEvent(sharedEventStore, event, YES))
            {
                //            returnValue.setUTF16String([event calendarItemIdentifier]);
                returnValue.setUTF16String([event calendarItemExternalIdentifier]);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    returnValue.setReturn(pResult);
}

void EK_EVENT_Set_start_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                
                Param2.fromParamAtIndex(pParams, 2);
                Param3.fromParamAtIndex(pParams, 3);
                NSDate *date = copyDate(Param2, Param3);
                event.startDate = date;
                success = saveItem(sharedEventStore, item, YES);
                [date release];
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_EVENT_Get_start_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                setDate(event.startDate, Param2, Param3);
                success = true;
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    PA_ReturnLong(params, success);
}

void EK_EVENT_Set_end_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                Param2.fromParamAtIndex(pParams, 2);
                Param3.fromParamAtIndex(pParams, 3);
                NSDate *date = copyDate(Param2, Param3);
                
                EKEvent *event = item;
                event.endDate = date;
                success = saveItem(sharedEventStore, item, YES);
                [date release];
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_EVENT_Get_end_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                setDate(event.endDate, Param2, Param3);
                success = true;
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    PA_ReturnLong(params, success);
}

void EK_EVENT_Get_occurrence_date(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param2;
    C_TIME Param3;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                setDate(event.occurrenceDate, Param2, Param3);
                success = true;
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    PA_ReturnLong(params, success);
}

void EK_EVENT_Get_status(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                Param2.setIntValue(event.status);
                success = true;
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_EVENT_Get_all_day(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                Param2.setIntValue(event.allDay);
                success = true;
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_EVENT_Set_all_day(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                Param2.fromParamAtIndex(pParams, 2);
                event.allDay = Param2.getIntValue();
                success = saveItem(sharedEventStore, item, YES);
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_EVENT_Get_organizer_name(PA_PluginParameters params) {

    BOOL success = false;
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param2;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        id item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = item;
                
                if(event.organizer)
                {
                    Param2.setUTF16String(event.organizer.name);
                    success = true;
                }
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    PA_ReturnLong(params, success);
}

void EK_EVENT_Save(PA_PluginParameters params) {

    BOOL success = false;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            
            success = saveItem(sharedEventStore, item, YES);
            
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_EVENT_Remove(PA_PluginParameters params) {

    BOOL success = false;
    
    if(request_permission_granted_for_events) {
        PA_Unistring *u = PA_GetStringParameter(params, 1);
        NSString *identifier = [[NSString alloc]initWithCharacters:u->fString length:u->fLength];
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        EKCalendarItem *item = getItem(sharedEventStore, identifier);
        
        if(!item){
            NSLog(@"'%@' does not exist", identifier);
        }else{
            if([item isKindOfClass:[EKEvent class]]){
                
                EKEvent *event = (EKEvent *)item;
                
                success = removeEvent(sharedEventStore, event, YES);
                
            }else{
                NSLog(@"'%@' is not an event", identifier);
            }
        }
        
        [sharedEventStore release];
        [identifier release];
    }
    
    PA_ReturnLong(params, success);
}

void EK_QUERY_EVENT(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param1;
    C_TIME Param2;
    C_DATE Param3;
    C_TIME Param4;
    ARRAY_TEXT Param5;
    ARRAY_TEXT Param6;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    NSDate *startDate = copyDate(Param1, Param2);
    
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    NSDate *endDate = copyDate(Param3, Param4);
    
    Param5.fromParamAtIndex(pParams, 5);
    
    if(request_permission_granted_for_events) {
        
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        NSArray *calendars = getCalendars(sharedEventStore, Param5);
        
        //    NSLog(@"[calendars count] %i", (int)[calendars count]);
        
        NSPredicate *predicate = [sharedEventStore predicateForEventsWithStartDate:startDate endDate:endDate calendars:[calendars count] ? calendars : nil];
        NSArray *events = [sharedEventStore eventsMatchingPredicate:predicate];
        
        Param6.setSize(1);
        for(unsigned int i = 0; i < [events count]; ++i)
        {
            EKEvent *event = [events objectAtIndex:i];
            //        Param6.appendUTF16String([event calendarItemIdentifier]);
            Param6.appendUTF16String([event calendarItemExternalIdentifier]);
        }
        
        Param6.toParamAtIndex(pParams, 6);
        
        [calendars release];
        [startDate release];
        [endDate release];
        
        [sharedEventStore release];
    }
}

void EK_QUERY_COMPLETE_REMINDER(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param1;
    C_TIME Param2;
    C_DATE Param3;
    C_TIME Param4;
    ARRAY_TEXT Param5;
    ARRAY_TEXT Param6;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    NSDate *startDate = copyDate(Param1, Param2);
    
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    NSDate *endDate = copyDate(Param3, Param4);
    
    Param5.fromParamAtIndex(pParams, 5);
    
    if(request_permission_granted_for_events) {
        
        dispatch_semaphore_t sema = dispatch_semaphore_create(0);
        
        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];
        
        NSArray *calendars = getCalendars(sharedEventStore, Param5);
        NSPredicate *predicate = [sharedEventStore predicateForCompletedRemindersWithCompletionDateStarting:startDate ending:endDate calendars:[calendars count] ? calendars : nil];
        
        NSMutableArray *reminderIdsForQuery = [[NSMutableArray alloc]init];
        [reminderIdsForQuery addObject:@""];
        
        [sharedEventStore fetchRemindersMatchingPredicate:predicate completion:^(NSArray *reminders){
            
            for (EKReminder *reminder in reminders)
            {
                //            [reminderIdsForQuery addObject:reminder.calendarItemIdentifier];
                [reminderIdsForQuery addObject:reminder.calendarItemExternalIdentifier];
            }
            
            dispatch_semaphore_signal(sema);
            
        }];
        
        dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
        
        setArray(reminderIdsForQuery, Param6);
        Param6.toParamAtIndex(pParams, 6);
        
        [reminderIdsForQuery release];
        [calendars release];
        [startDate release];
        [endDate release];

        [sharedEventStore release];
    }
}

void EK_QUERY_INCOMPLETE_REMINDER(PA_PluginParameters params) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_DATE Param1;
    C_TIME Param2;
    C_DATE Param3;
    C_TIME Param4;
    ARRAY_TEXT Param5;
    ARRAY_TEXT Param6;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    NSDate *startDate = copyDate(Param1, Param2);
    
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    NSDate *endDate = copyDate(Param3, Param4);
    
    Param5.fromParamAtIndex(pParams, 5);
    
    if(request_permission_granted_for_events) {
        
        dispatch_semaphore_t sema = dispatch_semaphore_create(0);

        EKEventStore *sharedEventStore = [[EKEventStore alloc]init];

        NSArray *calendars = getCalendars(sharedEventStore, Param5);
        NSPredicate *predicate = [sharedEventStore predicateForIncompleteRemindersWithDueDateStarting:startDate ending:endDate calendars:[calendars count] ? calendars : nil];
        
        NSMutableArray *reminderIdsForQuery = [[NSMutableArray alloc]init];
        [reminderIdsForQuery addObject:@""];
        
        [sharedEventStore fetchRemindersMatchingPredicate:predicate completion:^(NSArray *reminders){
            
            for (EKReminder *reminder in reminders)
            {
                //            [reminderIdsForQuery addObject:reminder.calendarItemIdentifier];
                [reminderIdsForQuery addObject:reminder.calendarItemExternalIdentifier];
            }
            
            dispatch_semaphore_signal(sema);
            
        }];
        
        dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
        
        setArray(reminderIdsForQuery, Param6);
        Param6.toParamAtIndex(pParams, 6);
        
        [reminderIdsForQuery release];
        [calendars release];
        [startDate release];
        [endDate release];
        
        [sharedEventStore release];
    }
}

request_permission_t requestPermission(EKEntityType entityType) {
    
    if (@available(macOS 10.9, *)) {
        
        switch ([EKEventStore authorizationStatusForEntityType:entityType])
        {
            case EKAuthorizationStatusNotDetermined:
            {
                EKEventStore *store = [EKEventStore new];
                [store requestAccessToEntityType:entityType completion:^(BOOL granted, NSError * _Nullable error) {
                    if (granted) {
                        switch (entityType) {
                            case EKEntityTypeEvent:
                            request_permission_granted_for_events = true;
                            break;
                            default:
                            request_permission_granted_for_reminders = true;
                            break;
                        }
                        
                    }
                }];
                return request_permission_not_determined;
                break;
            }
            break;
            case EKAuthorizationStatusRestricted:
            switch (entityType) {
                case EKEntityTypeEvent:
                request_permission_granted_for_events = false;
                break;
                default:
                request_permission_granted_for_reminders = false;
                break;
            }
            return request_permission_restricted;
            break;
            case EKAuthorizationStatusDenied:
            switch (entityType) {
                case EKEntityTypeEvent:
                request_permission_granted_for_events = false;
                break;
                default:
                request_permission_granted_for_reminders = false;
                break;
            }
            return request_permission_denied;
            break;
            case EKAuthorizationStatusAuthorized:
            switch (entityType) {
                case EKEntityTypeEvent:
                request_permission_granted_for_events = true;
                break;
                default:
                request_permission_granted_for_reminders = true;
                break;
            }
            return request_permission_authorized;
            break;
        }

    }
    return request_permission_unknown;
}

void EK_Request_permisson(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
#if VERSIONMAC
    NSBundle *mainBundle = [NSBundle mainBundle];
    if(mainBundle) {
        NSDictionary *infoDictionary = [mainBundle infoDictionary];
        if(infoDictionary) {

            NSString *calendarUsageDescription;
            switch (PA_GetLongParameter(params, 1)) {
                case 1:
                calendarUsageDescription = [infoDictionary objectForKey:@"NSRemindersUsageDescription"];
                break;
                default:
                calendarUsageDescription = [infoDictionary objectForKey:@"NSCalendarsUsageDescription"];
                break;
            }

            if(calendarUsageDescription) {
                
                SecTaskRef sec = SecTaskCreateFromSelf(kCFAllocatorMalloc);
                CFErrorRef err = nil;
                CFBooleanRef boolValue = (CFBooleanRef)SecTaskCopyValueForEntitlement(
                                                                                      SecTaskCreateFromSelf(NULL), CFSTR("com.apple.security.personal-information.calendars"), &err);
                if(!err) {
                    
                    if(boolValue) {
                        
                        if(CFBooleanGetValue(boolValue)) {
                            
                            request_permission_t permission;
                            
                            switch (PA_GetLongParameter(params, 1)) {
                                case 1:
                                permission = requestPermission(EKEntityTypeReminder);
                                break;
                                default:
                                permission = requestPermission(EKEntityTypeEvent);
                                break;
                            }
                            
                            switch (permission) {
                                
                                case request_permission_authorized:
                                ob_set_b(status, L"success", true);
                                break;
                                
                                case request_permission_denied:
                                ob_set_b(status, L"success", false);
                                ob_set_s(status, L"errorMessage", "permission denied");
                                break;
                                
                                case request_permission_restricted:
                                ob_set_b(status, L"success", false);
                                ob_set_s(status, L"errorMessage", "permission restricted");
                                break;
                                
                                case request_permission_not_determined:
                                ob_set_b(status, L"success", false);
                                ob_set_s(status, L"errorMessage", "permission not determined");
                                break;
                                
                                default:
                                break;
                            }
                        }
                        
                        if(request_permission_granted_for_events) {
                            ob_set_b(status, L"success", true);
                        }
                        
                        CFRelease(boolValue);
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "com.apple.security.device.camera is set to false in app entitlement");
                    }
                    
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "com.apple.security.device.camera is missing in app entitlement");
                }
                
                CFRelease(sec);
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "NScalendarUsageDescription is missing in app info.plist");
            }
        }else{
            ob_set_b(status, L"success", false);
            ob_set_s(status, L"errorMessage", "failed to locate [mainBundle infoDictionary]");
        }
    }else{
        ob_set_b(status, L"success", false);
        ob_set_s(status, L"errorMessage", "failed to locate [NSBundle mainBundle]");
    }
#endif
    
    PA_ReturnObject(params, status);
}
