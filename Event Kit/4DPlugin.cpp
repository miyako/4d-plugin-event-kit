/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Event Kit
 #	author : miyako
 #	2017/06/07
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- EK Store

		case 1 :
			EK_STORE_Commit(pResult, pParams);
			break;

// --- EK Source

		case 2 :
			EK_SOURCE_Get_type(pResult, pParams);
			break;

		case 3 :
			EK_SOURCE_Get_title(pResult, pParams);
			break;

		case 4 :
			EK_SOURCE_LIST(pResult, pParams);
			break;

		case 5 :
			EK_SOURCE_Calendar_list(pResult, pParams);
			break;

// --- EK Calendar

		case 6 :
			EK_CALENDAR_Get_rgb_color(pResult, pParams);
			break;

		case 7 :
			EK_CALENDAR_Set_rgb_color(pResult, pParams);
			break;

		case 8 :
			EK_CALENDAR_Remove(pResult, pParams);
			break;

		case 9 :
			EK_CALENDAR_Save(pResult, pParams);
			break;

		case 10 :
			EK_CALENDAR_Get_default(pResult, pParams);
			break;

		case 11 :
			EK_CALENDAR_Get_type(pResult, pParams);
			break;

		case 12 :
			EK_CALENDAR_LIST(pResult, pParams);
			break;

		case 13 :
			EK_CALENDAR_Create(pResult, pParams);
			break;

		case 14 :
			EK_CALENDAR_Get_title(pResult, pParams);
			break;

		case 15 :
			EK_CALENDAR_Set_title(pResult, pParams);
			break;

		case 16 :
			EK_CALENDAR_Get_source(pResult, pParams);
			break;

// --- EK Object

		case 17 :
			EK_OBJECT_ROLLBACK(pResult, pParams);
			break;

		case 18 :
			EK_OBJECT_RESET(pResult, pParams);
			break;

		case 19 :
			EK_OBJECT_REFRESH(pResult, pParams);
			break;

		case 20 :
			EK_OBJECT_Has_changes(pResult, pParams);
			break;

		case 21 :
			EK_OBJECT_Is_new(pResult, pParams);
			break;

// --- EK Item

		case 22 :
			EK_ITEM_Get_attendees(pResult, pParams);
			break;

		case 23 :
			EK_ITEM_Get_calendar(pResult, pParams);
			break;

		case 24 :
			EK_ITEM_Get_title(pResult, pParams);
			break;

		case 25 :
			EK_ITEM_Set_title(pResult, pParams);
			break;

		case 26 :
			EK_ITEM_Get_location(pResult, pParams);
			break;

		case 27 :
			EK_ITEM_Set_location(pResult, pParams);
			break;

		case 28 :
			EK_ITEM_Get_url(pResult, pParams);
			break;

		case 29 :
			EK_ITEM_Set_url(pResult, pParams);
			break;

		case 30 :
			EK_ITEM_Get_notes(pResult, pParams);
			break;

		case 31 :
			EK_ITEM_Set_notes(pResult, pParams);
			break;

		case 32 :
			EK_ITEM_Get_alarms(pResult, pParams);
			break;

		case 33 :
			EK_ITEM_Set_alarms(pResult, pParams);
			break;

		case 34 :
			EK_ITEM_Get_rules(pResult, pParams);
			break;

		case 35 :
			EK_ITEM_Set_rules(pResult, pParams);
			break;

		case 36 :
			EK_ITEM_Get_timezone(pResult, pParams);
			break;

		case 37 :
			EK_ITEM_Set_timezone(pResult, pParams);
			break;

		case 38 :
			EK_ITEM_Set_calendar(pResult, pParams);
			break;

		case 39 :
			EK_ITEM_Get_attendee_names(pResult, pParams);
			break;

		case 40 :
			EK_ITEM_Get_modification_date(pResult, pParams);
			break;

// --- EK Reminder

		case 41 :
			EK_REMINDER_Create(pResult, pParams);
			break;

		case 42 :
			EK_REMINDER_Set_start_date(pResult, pParams);
			break;

		case 43 :
			EK_REMINDER_Get_start_date(pResult, pParams);
			break;

		case 44 :
			EK_REMINDER_Set_due_date(pResult, pParams);
			break;

		case 45 :
			EK_REMINDER_Get_due_date(pResult, pParams);
			break;

		case 46 :
			EK_REMINDER_Set_completed_date(pResult, pParams);
			break;

		case 47 :
			EK_REMINDER_Get_completed_date(pResult, pParams);
			break;

		case 48 :
			EK_REMINDER_Remove(pResult, pParams);
			break;

		case 49 :
			EK_REMINDER_Save(pResult, pParams);
			break;

// --- EK Event

		case 50 :
			EK_EVENT_Create(pResult, pParams);
			break;

		case 51 :
			EK_EVENT_Set_start_date(pResult, pParams);
			break;

		case 52 :
			EK_EVENT_Get_start_date(pResult, pParams);
			break;

		case 53 :
			EK_EVENT_Set_end_date(pResult, pParams);
			break;

		case 54 :
			EK_EVENT_Get_end_date(pResult, pParams);
			break;

		case 55 :
			EK_EVENT_Get_occurrence_date(pResult, pParams);
			break;

		case 56 :
			EK_EVENT_Get_status(pResult, pParams);
			break;

		case 57 :
			EK_EVENT_Get_all_day(pResult, pParams);
			break;

		case 58 :
			EK_EVENT_Set_all_day(pResult, pParams);
			break;

		case 59 :
			EK_EVENT_Get_organizer_name(pResult, pParams);
			break;

		case 60 :
			EK_EVENT_Save(pResult, pParams);
			break;

		case 61 :
			EK_EVENT_Remove(pResult, pParams);
			break;

// --- EK Query

		case 62 :
			EK_QUERY_EVENT(pResult, pParams);
			break;

		case 63 :
			EK_QUERY_COMPLETE_REMINDER(pResult, pParams);
			break;

		case 64 :
			EK_QUERY_INCOMPLETE_REMINDER(pResult, pParams);
			break;

	}
}

// ----------------------------------- EK Store -----------------------------------

#pragma mark STORE

void EK_STORE_Commit(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT returnValue;
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	NSError *error;
	BOOL success = [sharedEventStore commit:&error];
	[sharedEventStore release];
	
	returnValue.setIntValue(success);
	returnValue.setReturn(pResult);
}

// ----------------------------------- EK Source ----------------------------------

#pragma mark SOURCE

void EK_SOURCE_Get_type(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
	Param2.setIntValue(source ? source.sourceType : 0);
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setIntValue(source ? 1 : 0);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_SOURCE_Get_title(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
	Param2.setUTF16String(source ? source.title : @"");
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setIntValue(source ? 1 : 0);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_SOURCE_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	NSArray *sources = [sharedEventStore sources];
	
	for(unsigned int i = 0; i < [sources count]; ++i)
	{
		EKSource *source = [sources objectAtIndex:i];
		Param1.appendUTF16String(source.sourceIdentifier);
	}
	Param1.toParamAtIndex(pParams, 1);
	
	[sharedEventStore release];
}

void EK_SOURCE_Calendar_list(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	C_LONGINT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param3.fromParamAtIndex(pParams, 3);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
	
	if(source)
	{
		NSArray *calendars = nil;
		switch (Param3.getIntValue())
		{
			case 0://events
				calendars = [[source calendarsForEntityType:EKEntityTypeEvent]allObjects];
				break;
			case 1://reminders
				calendars = [[source calendarsForEntityType:EKEntityTypeReminder]allObjects];
				break;
			default:
				break;
		}
		for(unsigned int i = 0; i < [calendars count]; ++i)
		{
			EKCalendar *calendar = [calendars objectAtIndex:i];
			Param2.appendUTF16String(calendar.calendarIdentifier);
		}
	}
	Param2.toParamAtIndex(pParams, 2);
	
	returnValue.setIntValue(source ? 1 : 0);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

// ---------------------------------- EK Calendar ---------------------------------

#pragma mark CALENDAR

BOOL saveCalendar(EKEventStore *sharedEventStore, EKCalendar *calendar)
{
	NSError *error;
	BOOL success = [sharedEventStore saveCalendar:calendar commit:NO error:&error];
	if(!success){
		NSLog(@"calendar save failed: %@", [error description]);
		return FALSE;
	}else{
		return TRUE;
	}
}

BOOL removeCalendar(EKEventStore *sharedEventStore, EKCalendar *calendar)
{
	NSError *error;
	BOOL success = [sharedEventStore removeCalendar:calendar commit:NO error:&error];
	if(!success){
		NSLog(@"calendar remove failed: %@", [error description]);
		return FALSE;
	}else{
		return TRUE;
	}
}

#pragma mark -

void EK_CALENDAR_Get_rgb_color(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_REAL Param2;
	C_REAL Param3;
	C_REAL Param4;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
	
	if(calendar)
	{
		NSColor *color = calendar.color;
		if(color)
		{
			CGFloat red, green, blue, alpha;
			[color getRed:&red green:&green blue:&blue alpha:&alpha];
			Param2.setDoubleValue(red);
			Param3.setDoubleValue(green);
			Param4.setDoubleValue(blue);
			returnValue.setIntValue(1);
		}
		
	}
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_CALENDAR_Set_rgb_color(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_REAL Param2;
	C_REAL Param3;
	C_REAL Param4;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
	
	if(calendar)
	{
		NSColor *color = [NSColor colorWithDeviceRed:Param2.getDoubleValue() green:Param3.getDoubleValue() blue:Param4.getDoubleValue() alpha:1];
		calendar.color = color;
		
		returnValue.setIntValue(saveCalendar(sharedEventStore, calendar));
	}
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_CALENDAR_Remove(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];

	if(calendar)
	{
		returnValue.setIntValue(removeCalendar(sharedEventStore, calendar));
	}
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_CALENDAR_Save(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
	
	if(calendar)
	{
		returnValue.setIntValue(saveCalendar(sharedEventStore, calendar));
	}
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_CALENDAR_Get_default(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	switch (Param1.getIntValue())
	{
		case 0://events
			Param2.setUTF16String(sharedEventStore.defaultCalendarForNewEvents.calendarIdentifier);
			returnValue.setIntValue(0 != [sharedEventStore.defaultCalendarForNewEvents.calendarIdentifier length]);
			break;
		case 1://reminders
			Param2.setUTF16String(sharedEventStore.defaultCalendarForNewReminders.calendarIdentifier);
			returnValue.setIntValue(0 != [sharedEventStore.defaultCalendarForNewReminders.calendarIdentifier length]);
			break;
		default:
			break;
	}
	Param2.toParamAtIndex(pParams, 2);
	
	returnValue.setReturn(pResult);

	[sharedEventStore release];
}

void EK_CALENDAR_Get_type(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
	
	if(calendar)
	{
		Param2.setIntValue(calendar.type);
		returnValue.setIntValue(1);
	}
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);

	[sharedEventStore release];
	[identifier release];
}

void EK_CALENDAR_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	C_LONGINT Param2;

	Param2.fromParamAtIndex(pParams, 2);

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];

	NSArray *calendars = nil;
	switch (Param2.getIntValue())
	{
		case 0://events
			calendars = [sharedEventStore calendarsForEntityType:EKEntityTypeEvent];
			break;
		case 1://reminders
			calendars = [sharedEventStore calendarsForEntityType:EKEntityTypeReminder];
			break;
		default:
			break;
	}
	for(unsigned int i = 0; i < [calendars count]; ++i)
	{
		EKCalendar *calendar = [calendars objectAtIndex:i];
		Param1.appendUTF16String(calendar.calendarIdentifier);
	}
	Param1.toParamAtIndex(pParams, 1);
	
	[sharedEventStore release];
}

void EK_CALENDAR_Create(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	EKEntityType type = (EKEntityType)Param2.getIntValue();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [EKCalendar calendarForEntityType:type eventStore:sharedEventStore];

	if(calendar)
	{
		if(saveCalendar(sharedEventStore, calendar))
		{
			returnValue.setUTF16String(calendar.calendarIdentifier);
		}
	}
	returnValue.setReturn(pResult);

	[sharedEventStore release];
	[identifier release];
}

void EK_CALENDAR_Get_title(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
	
	if(calendar)
	{
		Param2.setUTF16String(calendar.title);
		returnValue.setIntValue(1);
	}
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_CALENDAR_Set_title(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	NSString *title = Param2.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];

	if(calendar)
	{
		calendar.title = title;
		
		returnValue.setIntValue(saveCalendar(sharedEventStore, calendar));
	}
	
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[title release];
	[identifier release];
}

void EK_CALENDAR_Get_source(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
	
	if(calendar)
	{
		Param2.setUTF16String([calendar.source sourceIdentifier]);
		returnValue.setIntValue(1);
	}
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

// ----------------------------------- EK Object ----------------------------------

#pragma mark OBJECT

void EK_OBJECT_ROLLBACK(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
	
	if(source){
		[source rollback];
		NSLog(@"rolled back source '%@'", identifier);
	}else{
		EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
		if(calendar){
			[calendar rollback];
			NSLog(@"rolled back calendar '%@'", identifier);
		}else{
			EKCalendarItem *item = getItem(sharedEventStore, identifier);
			if(item){
				[item rollback];
				NSLog(@"rolled back item '%@'", identifier);
			}else{
				NSLog(@"'%@' is not a valid object to roll back", identifier);
			}
		}
	}
	
	[sharedEventStore release];
	[identifier release];
}

void EK_OBJECT_RESET(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];
	
	if(source){
		[source reset];
		NSLog(@"resetted source '%@'", identifier);
	}else{
		EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
		if(calendar){
			[calendar reset];
			NSLog(@"resetted calendar '%@'", identifier);
		}else{
			EKCalendarItem *item = getItem(sharedEventStore, identifier);
			if(item){
				[item reset];
				NSLog(@"resetted item '%@'", identifier);
			}else{
				[sharedEventStore reset];
				NSLog(@"resetted store");
			}
		}
	}
	
	[sharedEventStore release];
	[identifier release];
}

void EK_OBJECT_REFRESH(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];

	if(source){
		[source refresh];
		NSLog(@"refreshed source '%@'", identifier);
	}else{
		EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
		if(calendar){
			[calendar refresh];
			NSLog(@"refreshed calendar '%@'", identifier);
		}else{
			EKCalendarItem *item = getItem(sharedEventStore, identifier);
			if(item){
				[item refresh];
				NSLog(@"refreshed item '%@'", identifier);
			}else{
				[sharedEventStore refreshSourcesIfNecessary];
				NSLog(@"refreshed store");
			}
		}
	}
	
	[sharedEventStore release];
	[identifier release];
}

void EK_OBJECT_Has_changes(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];

	if(source){
		Param2.setIntValue([source hasChanges]);
	}else{
		EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
		if(calendar){
			Param2.setIntValue([calendar hasChanges]);
			returnValue.setIntValue(1);
		}else{
			EKCalendarItem *item = getItem(sharedEventStore, identifier);
			if(item){
				Param2.setIntValue([item hasChanges]);
				returnValue.setIntValue(1);
			}else{
				NSLog(@"'%@' is not a valid object to report changes", identifier);
			}
		}
	}
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

void EK_OBJECT_Is_new(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKSource *source = [sharedEventStore sourceWithIdentifier:identifier];

	if(source){
		Param2.setIntValue([source isNew]);
	}else{
		EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
		if(calendar){
			Param2.setIntValue([calendar isNew]);
			returnValue.setIntValue(1);
		}else{
			EKCalendarItem *item = getItem(sharedEventStore, identifier);
			if(item){
				Param2.setIntValue([item isNew]);
				returnValue.setIntValue(1);
			}else{
				NSLog(@"'%@' is not a valid object to report if new", identifier);
			}
		}
	}
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
	
	[sharedEventStore release];
	[identifier release];
}

// ------------------------------------ EK Item -----------------------------------

#pragma mark SAVE / REMOVE

BOOL saveEvent(EKEventStore *sharedEventStore, EKEvent *event, BOOL commit = NO)
{
	NSError *error;
	BOOL success = [sharedEventStore saveEvent:event span:EKSpanThisEvent commit:commit error:&error];
	if(!success){
		NSLog(@"event save failed: %@", [error description]);
		return FALSE;
	}else{
		return TRUE;
	}
}

BOOL removeEvent(EKEventStore *sharedEventStore, EKEvent *event, BOOL commit = NO)
{
	NSError *error;
	BOOL success = [sharedEventStore removeEvent:event span:EKSpanThisEvent commit:commit error:&error];
	
	if(!success){
		NSLog(@"event remove failed: %@", [error description]);
		return FALSE;
	}else{
		return TRUE;
	}
}

BOOL saveReminder(EKEventStore *sharedEventStore, EKReminder *reminder, BOOL commit = NO)
{
	NSError *error;
	BOOL success = [sharedEventStore saveReminder:reminder commit:commit error:&error];
	
	if(!success){
		NSLog(@"reminder save failed: %@", [error description]);
		return FALSE;
	}else{
		return TRUE;
	}
}

BOOL removeReminder(EKEventStore *sharedEventStore, EKReminder *reminder, BOOL commit = NO)
{
	NSError *error;
	BOOL success = [sharedEventStore removeReminder:reminder commit:commit error:&error];
	
	if(!success){
		NSLog(@"reminder remove failed: %@", [error description]);
		return FALSE;
	}else{
		return TRUE;
	}
}

BOOL saveItem(EKEventStore *sharedEventStore, EKCalendarItem *item, BOOL commit = NO)
{
	if(item)
	{
		if([item isKindOfClass:[EKEvent class]])
			if(saveEvent(sharedEventStore, (EKEvent *)item, commit))
				return TRUE;
		
		if([item isKindOfClass:[EKReminder class]])
			if(saveReminder(sharedEventStore, (EKReminder *)item, commit))
				return TRUE;
	}
	return FALSE;
}

#pragma mark ITEM

void EK_ITEM_Get_attendees(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		NSMutableArray *attendeeJsons = [[NSMutableArray alloc]init];
		
		NSArray *attendees = item.attendees;
		for (EKParticipant *attendee in attendees){
			
			NSString *name = attendee.name;
			
			NSNumber *participantRole = [NSNumber numberWithInt:attendee.participantRole];
			
			NSNumber *participantStatus = [NSNumber numberWithInt:attendee.participantStatus];
			
			id url;
			if(attendee.URL){
				url = [attendee.URL absoluteString];
			}else{
				url = [NSNull null];
			}
			
			NSDictionary *attendeeJson = [NSDictionary dictionaryWithObjects:
																		
																		[NSArray arrayWithObjects:
																		 name,
																		 participantRole,
																		 participantStatus,
																		 url,
																		 nil]
																															 forKeys:
																		
																		[NSArray arrayWithObjects:
																		 @"name",
																		 @"participantRole",
																		 @"participantStatus",
																		 @"url",
																		 nil]];
			NSError *error;
			NSData *jsonData = [NSJSONSerialization dataWithJSONObject:attendeeJson options:0 error:&error];
			
			if(jsonData){
				const void *bytes = [jsonData bytes];
				if(bytes){
					[attendeeJsons addObject:[NSString stringWithUTF8String:(const char *)bytes]];
				}
			}
		}
	
		setArray(attendeeJsons, Param2);
		[attendeeJsons release];
		returnValue.setIntValue(1);
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_calendar(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		Param2.setUTF16String(item.calendar.calendarIdentifier);
		returnValue.setIntValue(1);
	}

	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_calendar(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	NSString *calendar = Param2.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		EKCalendar *itemCalendar = [sharedEventStore calendarWithIdentifier:calendar];
		
		if(!itemCalendar){
			NSLog(@"'%@' is not a calendar", calendar);
		}else{
			item.calendar = itemCalendar;
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[calendar release];
	
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_title(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		Param2.setUTF16String(item.title);
		returnValue.setIntValue(1);
	}

	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_title(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	NSString *title = Param2.copyUTF16String();

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		item.title = title;
		returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
	}
	
	[sharedEventStore release];
	[identifier release];
	[title release];
	
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_location(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		Param2.setUTF16String(item.location);
		returnValue.setIntValue(1);
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_location(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	NSString *location = Param2.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		item.location = location;
		returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
	}
	
	[sharedEventStore release];
	[identifier release];
	[location release];
	
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_url(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		Param2.setUTF16String([item.URL absoluteString]);
		returnValue.setIntValue(1);
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_url(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	NSString *url = Param2.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		NSURL *URL = [NSURL URLWithString:url];
		if(URL){
			item.URL = URL;
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[url release];
	
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_notes(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		Param2.setUTF16String(item.notes);
		returnValue.setIntValue(1);
	}

	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_notes(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	NSString *notes = Param2.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		item.notes = notes;
		returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
	}
	
	[sharedEventStore release];
	[identifier release];
	[notes release];
	
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_alarms(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		NSMutableArray *itemAlarms = [[NSMutableArray alloc]init];
		NSArray *alarms = item.attendees;
		for (EKAlarm *alarm in alarms){
			
			NSNumber *type = [NSNumber numberWithInt:alarm.type];
			
			id soundName;
			if(alarm.soundName){
				soundName = alarm.soundName;
			}else{
				soundName = [NSNull null];
			}
			
			id emailAddress;
			if(alarm.emailAddress){
				emailAddress = alarm.emailAddress;
			}else{
				emailAddress = [NSNull null];
			}
			
			id url;
			if(alarm.url){
				url = [alarm.url absoluteString];
			}else{
				url = [NSNull null];
			}
			
			id relativeOffset;
			if(alarm.relativeOffset){
				relativeOffset = [NSNumber numberWithInt:alarm.relativeOffset];
			}else{
				relativeOffset = [NSNull null];
			}
			
			id absoluteDate;
			if(alarm.absoluteDate){
				absoluteDate = [alarm.absoluteDate description];
			}else{
				absoluteDate = [NSNull null];
			}
			
			id proximity;
			if(alarm.proximity){
				proximity = [NSNumber numberWithInt:alarm.proximity];
			}else{
				proximity = [NSNull null];
			}
			
			id structuredLocation;
			if(alarm.structuredLocation){
				structuredLocation = [NSDictionary dictionaryWithObjects:
															
															[NSArray arrayWithObjects:
															 alarm.structuredLocation.title,
															 [NSNumber numberWithDouble:alarm.structuredLocation.radius],
															 [NSNumber numberWithDouble:alarm.structuredLocation.geoLocation.coordinate.latitude],
															 [NSNumber numberWithDouble:alarm.structuredLocation.geoLocation.coordinate.longitude],
															 [NSNumber numberWithDouble:alarm.structuredLocation.geoLocation.altitude],
															 nil]
																												 forKeys:
															
															[NSArray arrayWithObjects:
															 @"title",
															 @"radius",
															 @"latitude",
															 @"longitude",
															 @"altitude",
															 nil]];
				
			}else{
				structuredLocation = [NSNull null];
			}
			
			NSDictionary *alarmJson = [NSDictionary dictionaryWithObjects:
																 
																	[NSArray arrayWithObjects:
																	 type,
																	 soundName,
																	 emailAddress,
																	 url,
																	 relativeOffset,
																	 absoluteDate,
																	 proximity,
																	 structuredLocation,
																	 nil]
																 
																														forKeys:
																 
																	[NSArray arrayWithObjects:
																	 @"type",
																	 @"soundName",
																	 @"emailAddress",
																	 @"url",
																	 @"relativeOffset",
																	 @"absoluteDate",
																	 @"proximity",
																	 @"structuredLocation",
																	 nil]];
			NSError *error;
			NSData *jsonData = [NSJSONSerialization dataWithJSONObject:alarmJson options:0 error:&error];
			
			if(jsonData){
				const void *bytes = [jsonData bytes];
				if(bytes){
					[itemAlarms addObject:[NSString stringWithUTF8String:(const char *)bytes]];
				}
			}
		}
	
		setArray(itemAlarms, Param2);
		[itemAlarms release];
		returnValue.setIntValue(1);
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_alarms(sLONG_PTR *pResult, PackagePtr pParams)
{
//	C_TEXT Param1;
//	ARRAY_TEXT Param2;
	C_LONGINT returnValue;

//	Param1.fromParamAtIndex(pParams, 1);
//	Param2.fromParamAtIndex(pParams, 2);

//TODO:not implemented
	
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_rules(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		NSMutableArray *itemRules = [[NSMutableArray alloc]init];
		NSArray *rules = item.recurrenceRules;
		for (EKRecurrenceRule *rule in rules){
			
			NSNumber *frequency = [NSNumber numberWithInt:rule.frequency];
			NSNumber *interval = [NSNumber numberWithInt:rule.interval];
			NSNumber *firstDayOfTheWeek = [NSNumber numberWithInt:rule.firstDayOfTheWeek];
			
			id recurrenceEnd;
			if(rule.recurrenceEnd){
				recurrenceEnd = [NSDictionary dictionaryWithObjects:
												 
												 [NSArray arrayWithObjects:
													[rule.recurrenceEnd.endDate description],
													[NSNumber numberWithInt:rule.recurrenceEnd.occurrenceCount],
													nil]
																										forKeys:
												 
												 [NSArray arrayWithObjects:
													@"endDate",
													@"occurrenceCount",
													nil]];
				
			}else{
				recurrenceEnd = [NSNull null];
			}
			
			id daysOfTheWeek;
			if(rule.daysOfTheWeek){
				
				daysOfTheWeek = [NSMutableArray array];
				
				for (EKRecurrenceDayOfWeek *dow in rule.daysOfTheWeek){
					
					NSDictionary *recurrence = [NSDictionary dictionaryWithObjects:
																			
																			[NSArray arrayWithObjects:
																			 [NSNumber numberWithInt:dow.dayOfTheWeek],
																			 [NSNumber numberWithInt:dow.weekNumber],
																			 nil]
																																 forKeys:
																			
																			[NSArray arrayWithObjects:
																			 @"dayOfTheWeek",
																			 @"weekNumber",
																			 nil]];
					
					[daysOfTheWeek addObject:recurrence];
					
				}
				
			}else{
				daysOfTheWeek = [NSNull null];
			}
			
			id daysOfTheMonth;
			if(rule.daysOfTheMonth){
				daysOfTheMonth = rule.daysOfTheMonth;
			}else{
				daysOfTheMonth = [NSNull null];
			}
			
			id daysOfTheYear;
			if(rule.daysOfTheYear){
				daysOfTheYear = rule.daysOfTheYear;
			}else{
				daysOfTheYear = [NSNull null];
			}
			
			id weeksOfTheYear;
			if(rule.weeksOfTheYear){
				weeksOfTheYear = rule.weeksOfTheYear;
			}else{
				weeksOfTheYear = [NSNull null];
			}
			
			id monthsOfTheYear;
			if(rule.monthsOfTheYear){
				monthsOfTheYear = rule.monthsOfTheYear;
			}else{
				monthsOfTheYear = [NSNull null];
			}
			
			id setPositions;
			if(rule.setPositions){
				setPositions = rule.setPositions;
			}else{
				setPositions = [NSNull null];
			}
			
			NSDictionary *alarmJson = [NSDictionary dictionaryWithObjects:
																 
																 [NSArray arrayWithObjects:
																	frequency,
																	interval,
																	firstDayOfTheWeek,
																	daysOfTheWeek,
																	daysOfTheMonth,
																	daysOfTheYear,
																	weeksOfTheYear,
																	monthsOfTheYear,
																	setPositions,
																	nil]
																 
																														forKeys:
																 
																 [NSArray arrayWithObjects:
																	@"frequency",
																	@"interval",
																	@"firstDayOfTheWeek",
																	@"daysOfTheWeek",
																	@"daysOfTheMonth",
																	@"daysOfTheYear",
																	@"weeksOfTheYear",
																	@"monthsOfTheYear",
																	@"setPositions",
																	nil]];
			NSError *error;							  
			NSData *jsonData = [NSJSONSerialization dataWithJSONObject:alarmJson options:0 error:&error];
			
			if(jsonData){
				const void *bytes = [jsonData bytes];
				if(bytes){
					[itemRules addObject:[NSString stringWithUTF8String:(const char*)bytes]];
				}
			}			
		}
	
		setArray(itemRules, Param2);
		[itemRules release];
		returnValue.setIntValue(1);
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_rules(sLONG_PTR *pResult, PackagePtr pParams)
{
//	C_TEXT Param1;
//	ARRAY_TEXT Param2;
	C_LONGINT returnValue;

//	Param1.fromParamAtIndex(pParams, 1);
//	Param2.fromParamAtIndex(pParams, 2);

//TODO:not implemented

	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_timezone(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		NSTimeZone *tz = item.timeZone;
		if(tz){
			Param2.setUTF16String([tz abbreviation]);
			returnValue.setIntValue(1);
		}
	}
	[sharedEventStore release];
	[identifier release];

	returnValue.setReturn(pResult);
}

void EK_ITEM_Set_timezone(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	NSString *zone = Param2.copyUTF16String();

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		NSTimeZone *tz = [NSTimeZone timeZoneWithAbbreviation:zone];
		if(tz){
			item.timeZone = tz;
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[zone release];
	
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_attendee_names(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	Param2.setSize(1);
	
	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		NSArray *attendees = item.attendees;
		for (EKParticipant *attendee in attendees)
		{
			Param2.appendUTF16String(attendee.name);
		}
		returnValue.setIntValue(1);
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_ITEM_Get_modification_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' is not a calendar item", identifier);
	}else{
		setDate(item.lastModifiedDate, Param2, Param3);
		returnValue.setIntValue(1);
	}
	
	[sharedEventStore release];
	[identifier release];

	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

// ---------------------------------- EK Reminder ---------------------------------

#pragma mark REMINDER

void EK_REMINDER_Create(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];
	
	if(!calendar){
		calendar = sharedEventStore.defaultCalendarForNewReminders;
	}
	
	if(!calendar){
		NSLog(@"'%@' is not a calendar", identifier);
	}else{
		EKReminder *reminder = [EKReminder reminderWithEventStore:sharedEventStore];
		reminder.calendar = calendar;
		
		if(saveReminder(sharedEventStore, reminder, YES))
		{
//			returnValue.setUTF16String([reminder calendarItemIdentifier]);
			returnValue.setUTF16String([reminder calendarItemExternalIdentifier]);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

void EK_REMINDER_Set_start_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	NSDate *date = copyDate(Param2, Param3);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKReminder class]]){
			
			EKReminder *reminder = (EKReminder *)item;
			NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
			NSUInteger dateComponentUnits = NSYearCalendarUnit|
			NSMonthCalendarUnit|
			NSDayCalendarUnit|
			NSHourCalendarUnit|
			NSMinuteCalendarUnit|
			NSSecondCalendarUnit|
			NSCalendarCalendarUnit|
			NSTimeZoneCalendarUnit;
			reminder.startDateComponents = [gregorianCalendar components:dateComponentUnits fromDate:date];
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
			[gregorianCalendar release];
			
		}else{
			NSLog(@"'%@' is not a reminder", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[date release];
	
	returnValue.setReturn(pResult);
}

void EK_REMINDER_Get_start_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKReminder class]]){
			
			EKReminder *reminder = (EKReminder *)item;
			NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
			NSUInteger dateComponentUnits = NSYearCalendarUnit|
			NSMonthCalendarUnit|
			NSDayCalendarUnit|
			NSHourCalendarUnit|
			NSMinuteCalendarUnit|
			NSSecondCalendarUnit|
			NSCalendarCalendarUnit|
			NSTimeZoneCalendarUnit;
			NSDate *date = [gregorianCalendar dateFromComponents:reminder.startDateComponents];
			setDate(date, Param2, Param3);
			returnValue.setIntValue(1);
		
		}else{
			NSLog(@"'%@' is not a reminder", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];

	returnValue.setReturn(pResult);
}

void EK_REMINDER_Set_due_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	NSDate *date = copyDate(Param2, Param3);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKReminder class]]){
			
			EKReminder *reminder = (EKReminder *)item;
			NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
			NSUInteger dateComponentUnits = NSYearCalendarUnit|
			NSMonthCalendarUnit|
			NSDayCalendarUnit|
			NSHourCalendarUnit|
			NSMinuteCalendarUnit|
			NSSecondCalendarUnit|
			NSCalendarCalendarUnit|
			NSTimeZoneCalendarUnit;
			reminder.dueDateComponents = [gregorianCalendar components:dateComponentUnits fromDate:date];
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
			[gregorianCalendar release];
			
		}else{
			NSLog(@"'%@' is not a reminder", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[date release];
	
	returnValue.setReturn(pResult);
}

void EK_REMINDER_Get_due_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKReminder class]]){
			
			EKReminder *reminder = (EKReminder *)item;
			NSCalendar *gregorianCalendar = [[NSCalendar alloc]initWithCalendarIdentifier:NSGregorianCalendar];
			NSUInteger dateComponentUnits = NSYearCalendarUnit|
			NSMonthCalendarUnit|
			NSDayCalendarUnit|
			NSHourCalendarUnit|
			NSMinuteCalendarUnit|
			NSSecondCalendarUnit|
			NSCalendarCalendarUnit|
			NSTimeZoneCalendarUnit;
			NSDate *date = [gregorianCalendar dateFromComponents:reminder.dueDateComponents];
			setDate(date, Param2, Param3);
			returnValue.setIntValue(1);
			
		}else{
			NSLog(@"'%@' is not a reminder", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

void EK_REMINDER_Set_completed_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	NSDate *date = copyDate(Param2, Param3);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKReminder class]]){
			
			EKReminder *reminder = (EKReminder *)item;
			reminder.completionDate = date;
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
			
		}else{
			NSLog(@"'%@' is not a reminder", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[date release];
	
	returnValue.setReturn(pResult);
}

void EK_REMINDER_Get_completed_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKReminder class]]){
			
			EKReminder *reminder = (EKReminder *)item;
			setDate(reminder.completionDate, Param2, Param3);
			returnValue.setIntValue(1);
			
		}else{
			NSLog(@"'%@' is not a reminder", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

void EK_REMINDER_Remove(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKReminder class]]){
			
			EKReminder *reminder = item;
			
			returnValue.setIntValue(removeReminder(sharedEventStore, reminder, YES));
			
		}else{
			NSLog(@"'%@' is not a reminder", identifier);
		}
	}

	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

void EK_REMINDER_Save(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		
		returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
		
	}
	
	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

// ----------------------------------- EK Event -----------------------------------

#pragma mark EVENT

void EK_EVENT_Create(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:identifier];

	if(!calendar){
		calendar = sharedEventStore.defaultCalendarForNewEvents;
	}
	
	if(!calendar){
		NSLog(@"'%@' is not a calendar", identifier);
	}else{
		EKEvent *event = [EKEvent eventWithEventStore:sharedEventStore];
		event.calendar = calendar;
		
		//mandatory properties to perform save
		event.startDate = [NSDate date];
		event.endDate = [NSDate date];
		
		if(saveEvent(sharedEventStore, event, YES))
		{
//			returnValue.setUTF16String([event calendarItemIdentifier]);
			returnValue.setUTF16String([event calendarItemExternalIdentifier]);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

void EK_EVENT_Set_start_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	NSDate *date = copyDate(Param2, Param3);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			event.startDate = date;
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[date release];
	
	returnValue.setReturn(pResult);
}

void EK_EVENT_Get_start_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			setDate(event.startDate, Param2, Param3);
			returnValue.setIntValue(1);
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}

	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

void EK_EVENT_Set_end_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	NSDate *date = copyDate(Param2, Param3);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			event.endDate = date;
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	[date release];
	
	returnValue.setReturn(pResult);
}

void EK_EVENT_Get_end_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			setDate(event.endDate, Param2, Param3);
			returnValue.setIntValue(1);
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

void EK_EVENT_Get_occurrence_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_DATE Param2;
	C_TIME Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			setDate(event.occurrenceDate, Param2, Param3);
			returnValue.setIntValue(1);
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

void EK_EVENT_Get_status(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			Param2.setIntValue(event.status);
			returnValue.setIntValue(1);
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_EVENT_Get_all_day(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			Param2.setIntValue(event.allDay);
			returnValue.setIntValue(1);
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_EVENT_Set_all_day(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			event.allDay = Param2.getIntValue();
			returnValue.setIntValue(saveItem(sharedEventStore, item, YES));
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_EVENT_Get_organizer_name(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	id item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = item;
			
			if(event.organizer)
			{
				Param2.setUTF16String(event.organizer.name);
				returnValue.setIntValue(1);
			}

		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void EK_EVENT_Save(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);

	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		
		returnValue.setIntValue(saveItem(sharedEventStore, item, YES));

	}
	
	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

void EK_EVENT_Remove(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	NSString *identifier = Param1.copyUTF16String();
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	EKCalendarItem *item = getItem(sharedEventStore, identifier);
	
	if(!item){
		NSLog(@"'%@' does not exist", identifier);
	}else{
		if([item isKindOfClass:[EKEvent class]]){
			
			EKEvent *event = (EKEvent *)item;
			
			returnValue.setIntValue(removeEvent(sharedEventStore, event, YES));
			
		}else{
			NSLog(@"'%@' is not an event", identifier);
		}
	}
	
	[sharedEventStore release];
	[identifier release];
	
	returnValue.setReturn(pResult);
}

// ----------------------------------- EK Query -----------------------------------

#pragma mark QUERY

BOOL setDate(NSDate *date, C_DATE &ParamDate, C_TIME &ParamTime)
{
	if(date){
		
		NSString *description = [date description];
		
		if([description length] == 25)
		{
			uint16_t year = [[description substringWithRange:NSMakeRange(0,4)]integerValue];
			uint16_t month = [[description substringWithRange:NSMakeRange(5,2)]integerValue];
			uint16_t day = [[description substringWithRange:NSMakeRange(8,2)]integerValue];
			
			unsigned char hour = [[description substringWithRange:NSMakeRange(11,2)]integerValue];
			unsigned char minute = [[description substringWithRange:NSMakeRange(14,2)]integerValue];
			unsigned char second = [[description substringWithRange:NSMakeRange(17,2)]integerValue];
			
			ParamDate.setYearMonthDay(year, month, day);
			ParamTime.setHourMinuteSecond(hour, minute, second);
			
			return TRUE;
		}
	}
	return FALSE;
}

NSDate *copyDate(C_DATE &ParamDate, C_TIME &ParamTime)
{
	uint16_t year;
	uint16_t month;
	uint16_t day;
	
	unsigned char hour;
	unsigned char minute;
	unsigned char second;
	
	ParamDate.getYearMonthDay(&year, &month, &day);
	ParamTime.getHourMinuteSecond(&hour, &minute, &second);
	
	CFGregorianDate gregDate;
	gregDate.year = year;
	gregDate.month = month;
	gregDate.day = day;
	gregDate.hour = hour;
	gregDate.minute = minute;
	gregDate.second = second;
	
	return (NSDate *)CFDateCreate(kCFAllocatorDefault, CFGregorianDateGetAbsoluteTime(gregDate, (CFTimeZoneRef)[NSTimeZone localTimeZone]));
}

void setArray(NSArray *array, ARRAY_TEXT &ParamArray)
{
	ParamArray.setSize(0);
	
	if(array){
		for(unsigned int i = 0; i < [array count]; ++i){
			
			ParamArray.appendUTF16String([array objectAtIndex:i]);
			
		}
	}
}

NSArray * copyArray(ARRAY_TEXT &ParamArray)
{
	NSUInteger capacity = ParamArray.getSize();
	NSMutableArray *array = [[NSMutableArray alloc]initWithCapacity:capacity];
	
	if(array){
		for(unsigned int i = 0; i < ParamArray.getSize(); ++i){
			
			NSString *item = ParamArray.copyUTF16StringAtIndex(i);
			[array addObject:item];
			[item release];
			
		}
	}
	return array;
}

NSArray *getCalendars(EKEventStore *sharedEventStore, ARRAY_TEXT &ParamArray)
{
	NSUInteger capacity = ParamArray.getSize();
	NSMutableArray *array = [[NSMutableArray alloc]initWithCapacity:capacity];
	
	if(array){
		for(unsigned int i = 0; i < ParamArray.getSize(); ++i){
			
			NSString *item = ParamArray.copyUTF16StringAtIndex(i);
			EKCalendar *calendar = [sharedEventStore calendarWithIdentifier:item];
			if(calendar)
			{
				[array addObject:calendar];
			}
			[item release];
		}
	}
	return array;
}

id getItem(EKEventStore *sharedEventStore, NSString *identifier)
{
	EKCalendarItem *item = nil;
	NSArray *items = [sharedEventStore calendarItemsWithExternalIdentifier:identifier];
	if([items count]) item = [items objectAtIndex:0];
	
	return item;
}

#pragma mark -

void EK_QUERY_EVENT(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_DATE Param1;
	C_TIME Param2;
	C_DATE Param3;
	C_TIME Param4;
	ARRAY_TEXT Param5;
	ARRAY_TEXT Param6;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	NSDate *startDate = copyDate(Param1, Param2);
	
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	NSDate *endDate = copyDate(Param3, Param4);
	
	Param5.fromParamAtIndex(pParams, 5);

	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	NSArray *calendars = getCalendars(sharedEventStore, Param5);
	
//	NSLog(@"[calendars count] %i", (int)[calendars count]);
	
	NSPredicate *predicate = [sharedEventStore predicateForEventsWithStartDate:startDate endDate:endDate calendars:[calendars count] ? calendars : nil];
	NSArray *events = [sharedEventStore eventsMatchingPredicate:predicate];

	Param6.setSize(1);
	for(unsigned int i = 0; i < [events count]; ++i)
	{
		EKEvent *event = [events objectAtIndex:i];
//		Param6.appendUTF16String([event calendarItemIdentifier]);
		Param6.appendUTF16String([event calendarItemExternalIdentifier]);
	}
	
	Param6.toParamAtIndex(pParams, 6);
	
	[sharedEventStore release];
	[calendars release];
	[startDate release];
	[endDate release];
}

void EK_QUERY_COMPLETE_REMINDER(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_DATE Param1;
	C_TIME Param2;
	C_DATE Param3;
	C_TIME Param4;
	ARRAY_TEXT Param5;
	ARRAY_TEXT Param6;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	NSDate *startDate = copyDate(Param1, Param2);
	
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	NSDate *endDate = copyDate(Param3, Param4);
	
	Param5.fromParamAtIndex(pParams, 5);
	
	dispatch_semaphore_t sema = dispatch_semaphore_create(0);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	NSArray *calendars = getCalendars(sharedEventStore, Param5);
	NSPredicate *predicate = [sharedEventStore predicateForCompletedRemindersWithCompletionDateStarting:startDate ending:endDate calendars:[calendars count] ? calendars : nil];
	
	NSMutableArray *reminderIdsForQuery = [[NSMutableArray alloc]init];
	[reminderIdsForQuery addObject:@""];
	
	[sharedEventStore fetchRemindersMatchingPredicate:predicate completion:^(NSArray *reminders){
		
		for (EKReminder *reminder in reminders)
		{
//			[reminderIdsForQuery addObject:reminder.calendarItemIdentifier];
			[reminderIdsForQuery addObject:reminder.calendarItemExternalIdentifier];
		}
		
		dispatch_semaphore_signal(sema);
		
	}];
	
	dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
	
	setArray(reminderIdsForQuery, Param6);
	Param6.toParamAtIndex(pParams, 6);
	
	[reminderIdsForQuery release];
	[sharedEventStore release];
	[calendars release];
	[startDate release];
	[endDate release];
}

void EK_QUERY_INCOMPLETE_REMINDER(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_DATE Param1;
	C_TIME Param2;
	C_DATE Param3;
	C_TIME Param4;
	ARRAY_TEXT Param5;
	ARRAY_TEXT Param6;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	NSDate *startDate = copyDate(Param1, Param2);
	
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	NSDate *endDate = copyDate(Param3, Param4);
	
	Param5.fromParamAtIndex(pParams, 5);
	
	dispatch_semaphore_t sema = dispatch_semaphore_create(0);
	
	EKEventStore *sharedEventStore = [[EKEventStore alloc]initWithAccessToEntityTypes:EKEntityMaskEvent|EKEntityMaskReminder];
	NSArray *calendars = getCalendars(sharedEventStore, Param5);
	NSPredicate *predicate = [sharedEventStore predicateForIncompleteRemindersWithDueDateStarting:startDate ending:endDate calendars:[calendars count] ? calendars : nil];
	
	NSMutableArray *reminderIdsForQuery = [[NSMutableArray alloc]init];
	[reminderIdsForQuery addObject:@""];
	
	[sharedEventStore fetchRemindersMatchingPredicate:predicate completion:^(NSArray *reminders){
		
		for (EKReminder *reminder in reminders)
		{
//			[reminderIdsForQuery addObject:reminder.calendarItemIdentifier];
			[reminderIdsForQuery addObject:reminder.calendarItemExternalIdentifier];
		}
		
		dispatch_semaphore_signal(sema);
		
	}];
	
	dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
	
	setArray(reminderIdsForQuery, Param6);
	Param6.toParamAtIndex(pParams, 6);
	
	[reminderIdsForQuery release];
	[sharedEventStore release];
	[calendars release];
	[startDate release];
	[endDate release];
}

